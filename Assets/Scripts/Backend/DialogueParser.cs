using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
//using Humanizer;

namespace VereTemereBackend {

/// <summary>
/// Creates a parser for dialogues, used with an <see cref="Npc"/>.
/// </summary>
public class DialogueParser : Tokenizer
{
    /// <summary>
    /// References the game dictionary and an NPC to parse tokens generated by the <see cref="Tokenizer"/>.
    /// </summary>
    /// <param name="tokens">The tokens generated by the tokenizer.</param>
    /// <param name="dictionary">The <see cref="Dictionary"/> object that contains all data about building types and
    /// possible properties (as well as all other game objects).</param>
    /// <param name="npc">The NPC that is being called from. Used to parse the tokens into text.</param>
    /// <param name="areas">The <see cref="Area"/> object list to reference.</param>
    public DialogueParser(List<DslToken> tokens, Dictionary dictionary, Npc npc, Dictionary<string, List<Area>> areas)
    {
        _tokens = tokens;
        _dictionary = dictionary;
        _npc = npc;
        _areas = areas;
    }
    
    // tokens
    private bool _nextIsOptional;
    private bool _nextIsPlural;
    //private bool _isPastTense;
    
    // ref
    private readonly Dictionary _dictionary;
    private readonly Npc _npc;
    
    // vars
    private List<string> _itemGroups = new List<string>();
    
    // util
    private readonly System.Random _random = new System.Random();
    private readonly List<DslToken> _tokens;
    
    private string? GetRandomItem()
    {
        List<DictionaryItem> items;
        if (_npc.Occupation!.Items?.Count > 0)
        {
            items = _dictionary.Items.Where(item => (bool)(_npc.Occupation.Items?.Contains(item.Name!))).ToList();
        }
        else
        {
            items = _dictionary.Items.ToList();
        }
        return items[_random.Next(0, items.Count)].Name;
    }

    private string? GetRandomAction()
    {
        if (_possibleActions.Count == 0) return "see";
        string? action = _possibleActions[_random.Next(0, _possibleActions.Count - 1)];
        return action;
    }
    
    private List<string?> _possibleActions = new List<string?>();
    private readonly Dictionary<string, object?> _values = new Dictionary<string, object?>();
    
    /// <summary>
    /// Generates a string based on the tokens given.
    /// </summary>
    /// <returns>The procesed string.</returns>
    public string MakeString()
    {
        StringBuilder text = new StringBuilder();
        if (!_npc.Quest.Active)
        {
            _values["item"] = GetRandomItem();
            _values["reward"] = "nothing";
            _values["count"] = _random.Next(1, 5);
        }
        else
        {
            _values["item"] = _npc.Quest.DictionaryItem.Name;
            _values["reward"] = $"{_npc.Quest.Reward, 5:C}";
            _values["count"] = _npc.Quest.DesiredItemCount;
        }
        _itemGroups = _dictionary.Items.Where(item => item.Name == _values["item"]!.ToString()).ToList()[0].Groups;
        _possibleActions = _dictionary.Items.Where(item => item.Name == _values["item"]!.ToString()).ToList()[0].Actions.ToList()!;
        _values["action"] = GetRandomAction();
        _values["occupation"] = _npc.Occupation!.Name;

        List<Area> areaList = _areas.SelectMany(area => area.Value).ToList();
        _values["home"] = areaList.Where(
                    area => area.Residents.Where(
                            resident => resident.Id == _npc.Id
                        ).ToList().Count == 1
                ).ToList()[0].Name;
        
        if (_values["home"] == null) _values["home"] = "";
        if ((string) _values["reward"]! != "nothing")
        {
            _values["pricemargin"] = _npc.Quest.Reward / (_dictionary.Items.Where(item => item.Name == _values["item"]!.ToString()).ToList()[0].Price * _npc.Quest.DesiredItemCount);
        }
        else
        {
            _values["pricemargin"] = 0;
        }

        _values["pricemargin"] = $"{Math.Round((double) _values["pricemargin"]! * 100) - 100}%";

        foreach (DslToken token in _tokens)
        {
            ProcessToken(token, text);
        }
        
        // if (_isPastTense)
        // {
        //     _isPastTense = false;
        //     try
        //     {
        //         EnglishSentence sentence = SentenceFactory.CreateSentence(text.ToString());
        //         sentence.Past();
        //         text = new StringBuilder(sentence.ToString());
        //     }
        //     catch
        //     {
        //         // ignored because sometimes times just aren't applicable
        //     }
        // }

        return text.ToString();
    }
    private void ProcessToken(DslToken token, StringBuilder text)
    {
        if (_nextIsOptional)
        {
            _nextIsOptional = false;
            if (_random.NextDouble() > 0.5) return;
        }

        if (token.GetTokenType() == TokenTypes.Optional)
        {
            _nextIsOptional = true;
            return;
        }
        
        if (token.GetTokenType() == TokenTypes.VariableStart || token.GetTokenType() == TokenTypes.VariableEnd)
        {
            return;
        }

        if (token.GetTokenType() == TokenTypes.Plural)
        {
            _nextIsPlural = true;
            return;
        }

        // if (token.GetTokenType() == TokenTypes.PastTense)
        // {
        //     _isPastTense = true;
        //     return;
        // }
        string buffer = GetFinalText(token);
        text.Append(buffer);
        
        
    }

    private string? GetFinalText(DslToken token)
    {
        string? text = token.Value!;
        
        // list of options
        if (token.GetTokenType() == TokenTypes.Or)
        {
            string?[] optionsArray = text.Substring(1, text.Length - 2).Split('|');
            text = optionsArray[_random.Next(0, optionsArray.Length)];
        } 
        else if (token.GetTokenType() == TokenTypes.Variable)
        {
            int length = token.Value!.Length - 1;
            if (_values.TryGetValue(token.Value, out object? value) || token.Value.Length < 4)
            {
                text = value!.ToString();
            }
            else
            {
                text = _values[token.Value.Substring(1, token.Value.Length - 2)]!.ToString();
            }

            if (_nextIsPlural)
            {
                _nextIsPlural = false;
                
                if (_tokens.Where(dslToken => dslToken.GetTokenType() == TokenTypes.Variable && dslToken.Value == "{count}").ToList().Count > 0)
                {
                    if ((int) _values["count"]! == 1)
                    {
                        return text;
                    }

                    //return text.Pluralize(false);
                    return text;
                }

                //if (token.Value[1..length] == "item" && _itemGroups[0] == "material")
                if (token.Value.Substring(1, length) == "item" && _itemGroups[0] == "material")
                {
                    // if ((int) _values["count"]! == 1) withOne = true;
                    return Singalize(text);
                }

                    //return text.Pluralize(false);
                    return text;
            }
        }

        return text;
    }

    private string Singalize(string? text)
    {
        var prefix = "one";
        // if (_vowelsThatNeedAnN.Contains(text![0..1]))
        // {
        //     prefix += "n";
        // }

        return $"{prefix} {text}";
    }

    private readonly List<string> _vowelsThatNeedAnN = new List<string>()
    {
        "a",
        "i"
    };

    private readonly Dictionary<string, List<Area>> _areas;
}
};